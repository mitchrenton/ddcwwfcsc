name: Deploy

on:
  push:
    branches:
      - staging

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Write SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Install paramiko
        run: pip3 install --quiet paramiko

      - name: Deploy
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
        run: |
          python3 << 'PYTHON'
          import paramiko, os, stat
          from pathlib import Path

          SSH_HOST     = os.environ['SSH_HOST']
          SSH_USERNAME = os.environ['SSH_USERNAME']
          SSH_PORT     = 65002
          KEY_PATH     = '/home/runner/.ssh/deploy_key'

          DEPLOYS = [
              ('wp-content/plugins/ddcwwfcsc',    'public_html/test/wp-content/plugins/ddcwwfcsc'),
              ('wp-content/themes/ddcwwfcsc-theme', 'public_html/test/wp-content/themes/ddcwwfcsc-theme'),
          ]

          key = paramiko.Ed25519Key.from_private_key_file(KEY_PATH)
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          ssh.connect(SSH_HOST, port=SSH_PORT, username=SSH_USERNAME, pkey=key)
          sftp = ssh.open_sftp()

          def mkdir_p(sftp, path):
              parts = []
              p = path
              while p and p != '/':
                  parts.append(p)
                  p = os.path.dirname(p)
              for d in reversed(parts):
                  try:
                      sftp.stat(d)
                  except FileNotFoundError:
                      sftp.mkdir(d)

          def list_remote_files(sftp, path):
              files = set()
              try:
                  for e in sftp.listdir_attr(path):
                      full = f"{path}/{e.filename}"
                      if stat.S_ISDIR(e.st_mode):
                          files.update(list_remote_files(sftp, full))
                      else:
                          files.add(full)
              except IOError:
                  pass
              return files

          def sync(sftp, local_dir, remote_dir):
              local = Path(local_dir)
              print(f'Syncing {local_dir} -> {remote_dir}')
              mkdir_p(sftp, remote_dir)

              remote_before = list_remote_files(sftp, remote_dir)
              remote_after  = set()

              for item in sorted(local.rglob('*')):
                  rel         = str(item.relative_to(local))
                  remote_path = f'{remote_dir}/{rel}'
                  if item.is_dir():
                      mkdir_p(sftp, remote_path)
                  else:
                      remote_after.add(remote_path)
                      sftp.put(str(item), remote_path)
                      print(f'  uploaded: {rel}')

              for stale in sorted(remote_before - remote_after):
                  sftp.remove(stale)
                  print(f'  deleted:  {stale}')

          for local_dir, remote_dir in DEPLOYS:
              sync(sftp, local_dir, remote_dir)

          sftp.close()
          ssh.close()
          print('Deployment complete.')
          PYTHON
